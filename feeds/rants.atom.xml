<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>MaxwellGBrown - rants</title><link href="/" rel="alternate"></link><link href="/feeds/rants.atom.xml" rel="self"></link><id>/</id><updated>2021-05-27T00:00:00-05:00</updated><entry><title>SQS to Lambda Makes Me Feel Bad</title><link href="/sqs-to-lambda-makes-me-feel-bad.html" rel="alternate"></link><published>2021-05-27T00:00:00-05:00</published><updated>2021-05-27T00:00:00-05:00</updated><author><name>Maxwell G Brown</name></author><id>tag:None,2021-05-27:/sqs-to-lambda-makes-me-feel-bad.html</id><summary type="html">&lt;h1&gt;SQS to Lambda Makes Me Feel Bad (&amp;amp; Misery Loves Company)&lt;/h1&gt;
&lt;p&gt;I myself remember a time (pre mid-2018) when AWS did not support SQS as a Lambda trigger. For the life of me I cannot find any recollection of this on the internet--it seems as the deep state has entirely scrubbed …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;SQS to Lambda Makes Me Feel Bad (&amp;amp; Misery Loves Company)&lt;/h1&gt;
&lt;p&gt;I myself remember a time (pre mid-2018) when AWS did not support SQS as a Lambda trigger. For the life of me I cannot find any recollection of this on the internet--it seems as the deep state has entirely scrubbed the internet of frustrated AWS users asking "why in god's name can't I go from SQS -&amp;gt; Lambda?!?!" (and, I myself used to be one of them).&lt;/p&gt;
&lt;p&gt;&lt;img alt="If an item doesn't appear in our records, it doesn't exist" src="/images/not-in-the-archives.png"&gt;&lt;/p&gt;
&lt;p&gt;Today, while searching for this exact case I find nothing but absolute celebration that our lord god AWS itself has delivered upon to us &lt;strong&gt;&lt;a href="https://aws.amazon.com/blogs/aws/aws-lambda-adds-amazon-simple-queue-service-to-supported-event-sources/"&gt;SQS as a Lambda trigger&lt;/a&gt;&lt;/strong&gt;. &lt;em&gt;He is risen!&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Okay so what's the problem?&lt;/h2&gt;
&lt;p&gt;Again, I cannot find &lt;strong&gt;any&lt;/strong&gt; mention on AWS's stance on SQS -&amp;gt; Lambda triggers pre June-2018.&lt;/p&gt;
&lt;p&gt;But everything in my memory tells me the reason it took ~4 years to integrate their very first service into their next-gen compute platform was not because nobody wanted it, but because &lt;em&gt;they disagreed with the entire premise of it&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="It ought to be here... but it isn't" src="/images/aught-to-isnt.png"&gt;&lt;/p&gt;
&lt;p&gt;Page and page of AWS Helpdesk questions (the public ones, I don't remember what they're called and I don't care to hunt it down) asking "HoW cAn I gEt SQS tO tRiGgEr A lAmBdA?" and AWS saying "please stop trying you're doing it wrong". Today, I can't find a single one of them, but I remember it deep in my soul because &lt;em&gt;I was asking the same question and was disatisfied with the answer&lt;/em&gt;!&lt;/p&gt;
&lt;p&gt;What I remember is their reasoning being something to the effect of:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SQS is a queueing mechanism for polling services to receive messages in an asynchronous fashion.
AWS Lambda is a computing service built to accept triggers, run, then terminate.
If you want to communicate asynchronously with AWS Lambda, &lt;em&gt;why don't you just send the message directly to the lambda?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I can hear me in 2017 right now: "Gah! I don't &lt;em&gt;want&lt;/em&gt; to trigger a lambda directly because I don't want to be tightly coupled to it!"&lt;/p&gt;
&lt;p&gt;...and maybe there's some merit to that. The whole purpose of queues is to allow you to throttle overflow on requests while the consumers can handle them at their leisure, so why should whomst is sending the message care about who consumes it? This is probably the only argument and reasoning I'll buy for Lambdas as a queue consumer. That and being to lazy to want to spin up real infrastructure (which I am certainly guilty of)&lt;/p&gt;
&lt;h2&gt;Why are we throtling small compuation nodes?&lt;/h2&gt;
&lt;p&gt;Lambda was not made to be big. It's whole purpose is to be a small computational node that executes quickly and scales near-infinittely horizontally.&lt;/p&gt;
&lt;p&gt;The hard part to scaling horizontally is already being performed by whomever is splitting the messages into batches for the queue anyways! &lt;/p&gt;
&lt;p&gt;Not to mention, Lambda has a feature for running asynchronously (as opposed to a request-response cycle) so you don't have to wait for a response.&lt;/p&gt;
&lt;p&gt;Oh, did I mention that if trigger events fail to be processed or overflow past your throttle when you reach your lambda limit, &lt;em&gt;you can configure a Dead-Letter Queue to catch them?&lt;/em&gt;. &lt;/p&gt;
&lt;h3&gt;Also, are we &lt;em&gt;really&lt;/em&gt; decoupled?&lt;/h3&gt;
&lt;p&gt;Not to mention, you're publishing a message to a queue, a message that fits into the queue that you know is going to be picked up by a service expecting it to be in &lt;em&gt;some shape&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;If you published that message directly to Lambda you'd get effectively the same result from the producer perspective!&lt;/p&gt;
&lt;p&gt;The only real benefit you're getting is offloading the computation of &lt;em&gt;something&lt;/em&gt;, and you don't care what it is. If that's what we're going for, I posit there are better ways to do that.&lt;/p&gt;
&lt;h2&gt;What if there was something... better&lt;/h2&gt;
&lt;p&gt;&lt;img alt="I want you to join me" src="/images/join-me.gif"&gt;&lt;/p&gt;
&lt;p&gt;Okay so I don't think you should go from SQS -&amp;gt; Lambda. What then, is that it?&lt;/p&gt;
&lt;p&gt;Replacing the good-ol' push/pull model is the (imo much more flexible) pub/sub model.&lt;/p&gt;
&lt;p&gt;Instead of connecting your services together with queues, we should first consider an &lt;strong&gt;Event Bus&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;In this world, the service lives in an ecosystem of other services all connected by messages flowing through an Event Bus. Subscribe to the ones you like, and process them there! Your service is already supposed to handle events idempotently if you're considering using a service in the first place, so you've already handled the hard part.&lt;/p&gt;
&lt;p&gt;The prerequisites to get Event Bus ready are already so similar to getting it queue ready:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You should be handling events idempotently&lt;/li&gt;
&lt;li&gt;You should be able to scale horizontally to handle load (which, I guess isn't necessarily required for queue consumers, but if you want messages to be handled timely...)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;...and you get the ability to do &lt;em&gt;so much more&lt;/em&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Listen to multiple different types of events, instead of just the ones you couple to the queue&lt;/li&gt;
&lt;li&gt;Publish messages &lt;em&gt;back&lt;/em&gt; to the event bus for other services to consume&lt;/li&gt;
&lt;li&gt;Decouple other services from producing to &lt;em&gt;your queue&lt;/em&gt; and instead couple them to the Event Bus enviornment (biome?) where they can talk to the rest of the animal kingdom!&lt;/li&gt;
&lt;li&gt;(I could go on and on about what I think Event Busses enable, but these two are the most pertinant for now)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Queues still serve a purpose: throttling expensive asynchronous operations! But shoe-horning them into being glorified message brokers is doing everybody a disservice, and is something SNS &lt;em&gt;was literally made to do&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;In Conclusion...&lt;/h2&gt;
&lt;p&gt;If you're using Lambdas as SQS Queue consumers then maybe you're doing it wrong.&lt;/p&gt;</content><category term="rants"></category></entry><entry><title>Everything is MapReduce</title><link href="/everything-is-mapreduce.html" rel="alternate"></link><published>2021-05-26T00:00:00-05:00</published><updated>2021-05-26T00:00:00-05:00</updated><author><name>Maxwell G Brown</name></author><id>tag:None,2021-05-26:/everything-is-mapreduce.html</id><summary type="html">&lt;h1&gt;Everything is MapReduce&lt;/h1&gt;
&lt;p&gt;&lt;img alt="MapReduce. MapReduce everywhere." src="/images/mapreduce-everywhere.jpg"&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Product&lt;/strong&gt;: "It's time to write some data processing! We have files that may have records in the tens of thousands, and we need to categorize/label/process/onboard them into our system after submission from an HTTP request!"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(naive) Dev&lt;/strong&gt;: "Uuh, let's just do it in a …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;h1&gt;Everything is MapReduce&lt;/h1&gt;
&lt;p&gt;&lt;img alt="MapReduce. MapReduce everywhere." src="/images/mapreduce-everywhere.jpg"&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Product&lt;/strong&gt;: "It's time to write some data processing! We have files that may have records in the tens of thousands, and we need to categorize/label/process/onboard them into our system after submission from an HTTP request!"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(naive) Dev&lt;/strong&gt;: "Uuh, let's just do it in a blocking API request in a single procedural function the size of Texas?"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QA&lt;/strong&gt;: "Hey, so the processing form doesn't work for any files larger than 500kb..."&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PM&lt;/strong&gt;: "I'll write a ticket to increase the file size!"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It's not the first time I've had to write a system like the above and it likely won't be the last. And it won't be the first time that a developer (naively, I feel) suggests taking an incremenetal approach to implementing it first in a blocking API call that just &lt;em&gt;does everything&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;Very quickly though the team outgrows these implementations (probably because blocking API calls are a &lt;em&gt;Bad Idea&lt;/em&gt;) and then the poor dev (or even worse, his successor!) is stuck with a ticket that says something like "increase import size from 500kb" and they find themselves trying to build Rome with a hammer &amp;amp; chisel.&lt;/p&gt;
&lt;h2&gt;Let's make it right&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;This rant is about MapReduce &lt;em&gt;right&lt;/em&gt;?&lt;/strong&gt; Bear with me.&lt;/p&gt;
&lt;p&gt;I posit that the real problem here is starting with the &lt;em&gt;wrong&lt;/em&gt; incremental approach: building that asynchronous system into the request-response cycle should be the very FIRST thing that happens here! &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A queue with a listener that has some beefy stats? Sure okay.&lt;/li&gt;
&lt;li&gt;On-demand compute nodes to run tasks in long form fashion? Yeah, that might work.&lt;/li&gt;
&lt;li&gt;An event bus and some horizontally-scalable microservices? Sounds fun.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It doesn't ned to be entirely fleshed out, let it be an infant! Maybe you're just moving your procedural abomination downstream. Don't care, it's better now that you're not on a blocking API request.&lt;/p&gt;
&lt;p&gt;Blocking API requests are like getting groceries during COVID: you want to deliver your message and get the hell out. Any time you spend standing in line should be making you anxious about the things happening around you.&lt;/p&gt;
&lt;p&gt;We probably skip away from this implementation happy that we've built something cool and loosened the valve on the future featurres we have to build into our asynchronous processing system.&lt;/p&gt;
&lt;h2&gt;Okay what next?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Where is the MapReduce?&lt;/strong&gt; &lt;em&gt;Yeah yeah&lt;/em&gt; I'm getting there.&lt;/p&gt;
&lt;p&gt;We have our nice pretty custom asynchronous data processing tooling, and it's way better than what we had before. I mean &lt;em&gt;way&lt;/em&gt; better. We can actually add features to it without worry that "rEqUeStS wILl TiMe OuT!". &lt;/p&gt;
&lt;p&gt;We've introduced more infrastructure overhead (after all, we &lt;em&gt;did&lt;/em&gt; solve this problem with more infrastructure). The solution is pretty custom, lets say that there's 5 steps in our flow and each step transforms and does some processing against the data. Let's pencil it out:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Turn XLSX rows into JSON data&lt;/li&gt;
&lt;li&gt;Read JSON records for an ID to insert/update into our system&lt;/li&gt;
&lt;li&gt;Read certain fields in said records for URLs of images&lt;/li&gt;
&lt;li&gt;Download said images&lt;/li&gt;
&lt;li&gt;Insert/update database with some light processing/transformed of values (e.g. whitespace trimming)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;...and maybe to do this we have a workflow manager that manages moving between steps for us! When 1 is done, do 2. When 2 is done do 3. Do I need to do step 4? No? Skip to 5.&lt;/p&gt;
&lt;p&gt;All the while, dropping our intermediate data somewhere so we can both pick it up at the next step or audit it after the fact.&lt;/p&gt;
&lt;h3&gt;In case you hadn't noticed...&lt;/h3&gt;
&lt;p&gt;&lt;img alt="It's all MapReduce? Always has been." src="/images/mapreduce-always-has-been.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;This rant is about MapReduce now!&lt;/h2&gt;
&lt;p&gt;We did all this work just to implement a glorified MapReduce!&lt;/p&gt;
&lt;p&gt;And we &lt;em&gt;haaaate&lt;/em&gt; unnecessary work. Why build something custom when you can worry about less and finger-point at other vendors when your stuff isn't working right?&lt;/p&gt;
&lt;p&gt;Here's the hot-take of the day: &lt;strong&gt;All data processing is just glorified MapReduce&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Why do we even bother building our own things when we have these solutions that are hand-tailored to ripping apart and processing large swaths of data!? Would we have not done ourselves a service by starting directly with Hadoop, or a mature MapReduce-ing solution?&lt;/p&gt;
&lt;h2&gt;I don't see it yet&lt;/h2&gt;
&lt;p&gt;It's in the name. MapReduce is two main parts:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Map&lt;/strong&gt; initial data into keys that correspond to how we're processing the data&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Reduce&lt;/strong&gt; mapped data into "organized" data that we want to work with&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;...and if we want to get into specifics those two actually have other steps to talk about:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Map&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Input
  Give the initial input&lt;/li&gt;
&lt;li&gt;Split
  Split initial data into processable chunks&lt;/li&gt;
&lt;li&gt;Map
  Take a chunk and key the records you want from it&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Reduce&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Shuffle
  Across the chunks, organize data into logical groups&lt;/li&gt;
&lt;li&gt;Reduce
  Turn the logical groups into new data&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;With those enumerated, it's a lot easier to see how our problem statement fits so well into this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Turn XLSX rows into JSON data&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Input&lt;/strong&gt; XLSX file&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Split&lt;/strong&gt; XLSX rows into JSON data&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Read JSON records for an ID to insert/update into our system&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Map&lt;/strong&gt; JSON records into keys&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shuffle&lt;/strong&gt; records into separate "Inserts" and "Update" groups&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Read certain fields in said records for URLs of images (the ordered list is doing me a disservice now, since this will likely happen simultaneous to 2, but the show must go on)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Map&lt;/strong&gt; fields with URLs&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Download said images&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Reduce&lt;/strong&gt; URLs to new hosted location&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Insert/update database with some light processing/transformed of values (e.g. whitespace trimming)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Reduce&lt;/strong&gt; to new records&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Did I mention that each of these steps saves the intermediate data, so we can audit between steps? &lt;/p&gt;
&lt;p&gt;I've built systems similar to this thrice over at my job, and whenever I take a step back to admire my handiwork I end up thinking to myself:&lt;/p&gt;
&lt;h3&gt;Did I just build a glorified MapReduce?&lt;/h3&gt;
&lt;p&gt;&lt;img alt="Who are you? Rey. Rey MapReduce" src="/images/rey-mapreduce.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;Confession/Disclaimer&lt;/h2&gt;
&lt;p&gt;I have no idea what I'm talking about. I've never actually used Hadoop before, nor any of the othere "MapReducers" I could find in a 3-minute google sesh (Apache Spark, Apache Storm, BigQuery, Disco).&lt;/p&gt;
&lt;p&gt;But here I am with the confession that I've ~wasted~ spent plenty of time implementing solutions that would likely fit into the category of "Hadoop Alternative".&lt;/p&gt;
&lt;p&gt;So, perhaps this rant was more for &lt;em&gt;me&lt;/em&gt; than any reader:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Maybe I should look into Hadoop or it's alternatives?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="rants"></category></entry></feed>